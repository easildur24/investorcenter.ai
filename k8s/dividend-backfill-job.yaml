apiVersion: batch/v1
kind: Job
metadata:
  name: dividend-backfill-initial
  namespace: investorcenter
spec:
  ttlSecondsAfterFinished: 86400  # Clean up after 24 hours
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: dividend-fetcher
        image: python:3.11-slim
        command: ["/bin/bash", "-c"]
        args:
          - |
            pip install psycopg2-binary requests
            cat > /tmp/fetch_dividends.py << 'SCRIPT'
            import os
            import sys
            import time
            import logging
            from datetime import datetime
            import psycopg2
            from psycopg2.extras import execute_batch
            import requests

            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
            logger = logging.getLogger(__name__)

            class DividendFetcher:
                def __init__(self):
                    self.db_config = {
                        'host': os.environ.get('DB_HOST', 'localhost'),
                        'port': int(os.environ.get('DB_PORT', 5432)),
                        'database': os.environ.get('DB_NAME', 'investorcenter_db'),
                        'user': os.environ.get('DB_USER'),
                        'password': os.environ.get('DB_PASSWORD')
                    }
                    self.api_key = os.environ.get('POLYGON_API_KEY')
                    if not self.api_key:
                        raise ValueError("POLYGON_API_KEY required")
                    self.conn = None
                    self.stats = {'processed': 0, 'fetched': 0, 'inserted': 0, 'errors': 0}
                    self.request_interval = 0.2
                    self.last_request_time = 0

                def connect_db(self):
                    self.conn = psycopg2.connect(**self.db_config)
                    logger.info(f"Connected to database")
                    return True

                def rate_limit(self):
                    elapsed = time.time() - self.last_request_time
                    if elapsed < self.request_interval:
                        time.sleep(self.request_interval - elapsed)
                    self.last_request_time = time.time()

                def fetch_dividends(self, ticker):
                    url = "https://api.polygon.io/v3/reference/dividends"
                    params = {'ticker': ticker, 'limit': 100, 'apiKey': self.api_key}
                    try:
                        self.rate_limit()
                        response = requests.get(url, params=params, timeout=10)
                        response.raise_for_status()
                        data = response.json()
                        if data.get('status') == 'OK' and 'results' in data:
                            return data['results']
                        return []
                    except Exception as e:
                        self.stats['errors'] += 1
                        return []

                def get_tickers(self):
                    with self.conn.cursor() as cursor:
                        cursor.execute("""
                            SELECT symbol FROM (
                                SELECT DISTINCT t.symbol, t.market_cap
                                FROM tickers t
                                LEFT JOIN dividends d ON t.symbol = d.symbol
                                WHERE t.asset_type IN ('stock', 'CS')
                                  AND t.active = true
                                  AND d.symbol IS NULL
                            ) sub
                            ORDER BY market_cap DESC NULLS LAST
                        """)
                        return [row[0] for row in cursor.fetchall()]

                def insert_dividends(self, ticker, dividends):
                    if not dividends:
                        return 0
                    try:
                        with self.conn.cursor() as cursor:
                            records = []
                            for div in dividends:
                                records.append((
                                    ticker,
                                    div.get('ex_dividend_date'),
                                    div.get('pay_date'),
                                    div.get('record_date'),
                                    div.get('declaration_date'),
                                    div.get('cash_amount', 0),
                                    div.get('currency', 'USD'),
                                    div.get('frequency'),
                                    div.get('dividend_type', 'CD')
                                ))
                            execute_batch(cursor, """
                                INSERT INTO dividends (
                                    symbol, ex_date, pay_date, record_date, declaration_date,
                                    amount, currency, frequency, type
                                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                                ON CONFLICT (symbol, ex_date, type) DO UPDATE SET
                                    pay_date = EXCLUDED.pay_date,
                                    amount = EXCLUDED.amount,
                                    updated_at = CURRENT_TIMESTAMP
                            """, records, page_size=100)
                            self.conn.commit()
                            return len(records)
                    except Exception as e:
                        logger.error(f"Insert error for {ticker}: {e}")
                        self.conn.rollback()
                        return 0

                def run(self):
                    start_time = datetime.now()
                    logger.info("=" * 60)
                    logger.info("Dividend Data Fetcher - Initial Backfill")
                    logger.info("=" * 60)

                    self.connect_db()
                    tickers = self.get_tickers()
                    logger.info(f"Processing {len(tickers)} tickers without dividend data")

                    for i, symbol in enumerate(tickers):
                        if (i + 1) % 100 == 0:
                            logger.info(f"Progress: {i + 1}/{len(tickers)} - Inserted: {self.stats['inserted']}")

                        dividends = self.fetch_dividends(symbol)
                        self.stats['processed'] += 1
                        self.stats['fetched'] += len(dividends)

                        if dividends:
                            inserted = self.insert_dividends(symbol, dividends)
                            self.stats['inserted'] += inserted

                    duration = datetime.now() - start_time
                    logger.info("=" * 60)
                    logger.info(f"Completed in {duration}")
                    logger.info(f"Tickers: {self.stats['processed']}, Dividends: {self.stats['inserted']}, Errors: {self.stats['errors']}")
                    self.conn.close()

            if __name__ == '__main__':
                DividendFetcher().run()
            SCRIPT
            python /tmp/fetch_dividends.py
        env:
        - name: POLYGON_API_KEY
          valueFrom:
            secretKeyRef:
              name: polygon-api-secret
              key: api-key
        - name: DB_HOST
          value: "postgres-simple-service"
        - name: DB_PORT
          value: "5432"
        - name: DB_NAME
          value: "investorcenter_db"
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
  backoffLimit: 3

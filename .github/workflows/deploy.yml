name: Deploy to EKS

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      frontend:
        description: Deploy frontend
        type: boolean
        default: false
      backend:
        description: Deploy backend
        type: boolean
        default: false
      notification-service:
        description: Deploy notification-service
        type: boolean
        default: false
      data-ingestion-service:
        description: Deploy data-ingestion-service
        type: boolean
        default: false
      ic-score-service:
        description: Deploy ic-score-service
        type: boolean
        default: false
      task-service:
        description: Deploy task-service
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 360358043271.dkr.ecr.us-east-1.amazonaws.com
  EKS_CLUSTER: investorcenter-eks
  NAMESPACE: investorcenter

permissions:
  id-token: write
  contents: read

jobs:
  # ---------------------------------------------------------------------------
  # Detect which services changed (push only — workflow_dispatch uses inputs)
  # ---------------------------------------------------------------------------
  detect-changes:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      backend: ${{ steps.filter.outputs.backend }}
      notification-service: ${{ steps.filter.outputs.notification-service }}
      data-ingestion-service: ${{ steps.filter.outputs.data-ingestion-service }}
      ic-score-service: ${{ steps.filter.outputs.ic-score-service }}
      task-service: ${{ steps.filter.outputs.task-service }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'app/**'
              - 'components/**'
              - 'lib/**'
              - 'public/**'
              - 'middleware.ts'
              - 'package.json'
              - 'package-lock.json'
              - 'next.config.js'
              - 'tailwind.config.ts'
              - 'Dockerfile'
            backend:
              - 'backend/**'
            notification-service:
              - 'notification-service/**'
            data-ingestion-service:
              - 'data-ingestion-service/**'
            ic-score-service:
              - 'ic-score-service/**'
              - '!ic-score-service/k8s/**'
            task-service:
              - 'task-service/**'

  # ---------------------------------------------------------------------------
  # Wait for CI to pass (push only — workflow_dispatch skips this)
  # ---------------------------------------------------------------------------
  wait-for-ci:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: detect-changes
    steps:
      - uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ github.sha }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          check-name: build
          wait-interval: 15
          allowed-conclusions: success

  # ---------------------------------------------------------------------------
  # Deploy Frontend
  # ---------------------------------------------------------------------------
  deploy-frontend:
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.frontend == 'true') ||
      (github.event_name == 'push' && needs.detect-changes.outputs.frontend == 'true' && needs.wait-for-ci.result == 'success')
    needs: [detect-changes, wait-for-ci]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/frontend
          docker build --platform linux/amd64 \
            -t $IMAGE:${{ github.sha }} \
            -t $IMAGE:latest \
            -f Dockerfile .
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

      - name: Deploy to EKS
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/frontend:${{ github.sha }}
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl set image deployment/investorcenter-frontend \
            investorcenter-frontend=$IMAGE \
            -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/investorcenter-frontend -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/investorcenter-frontend -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          READY=$(kubectl get deployment investorcenter-frontend -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment investorcenter-frontend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          echo "Ready: $READY / $DESIRED"
          [ "$READY" = "$DESIRED" ] || exit 1

  # ---------------------------------------------------------------------------
  # Deploy Backend
  # ---------------------------------------------------------------------------
  deploy-backend:
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.backend == 'true') ||
      (github.event_name == 'push' && needs.detect-changes.outputs.backend == 'true' && needs.wait-for-ci.result == 'success')
    needs: [detect-changes, wait-for-ci]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/backend
          cd backend
          docker build --platform linux/amd64 \
            -t $IMAGE:${{ github.sha }} \
            -t $IMAGE:latest \
            -f Dockerfile .
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

      - name: Deploy to EKS
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/backend:${{ github.sha }}
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl set image deployment/investorcenter-backend \
            investorcenter-backend=$IMAGE \
            -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/investorcenter-backend -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/investorcenter-backend -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          READY=$(kubectl get deployment investorcenter-backend -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment investorcenter-backend -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          echo "Ready: $READY / $DESIRED"
          [ "$READY" = "$DESIRED" ] || exit 1

  # ---------------------------------------------------------------------------
  # Deploy Notification Service
  # ---------------------------------------------------------------------------
  deploy-notification-service:
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.notification-service == 'true') ||
      (github.event_name == 'push' && needs.detect-changes.outputs.notification-service == 'true' && needs.wait-for-ci.result == 'success')
    needs: [detect-changes, wait-for-ci]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/notification-service
          cd notification-service
          docker build --platform linux/amd64 \
            -t $IMAGE:${{ github.sha }} \
            -t $IMAGE:latest \
            -f Dockerfile .
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

      - name: Deploy to EKS
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/notification-service:${{ github.sha }}
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl set image deployment/notification-service \
            notification-service=$IMAGE \
            -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/notification-service -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/notification-service -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          READY=$(kubectl get deployment notification-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment notification-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          echo "Ready: $READY / $DESIRED"
          [ "$READY" = "$DESIRED" ] || exit 1

  # ---------------------------------------------------------------------------
  # Deploy Data Ingestion Service
  # ---------------------------------------------------------------------------
  deploy-data-ingestion-service:
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.data-ingestion-service == 'true') ||
      (github.event_name == 'push' && needs.detect-changes.outputs.data-ingestion-service == 'true' && needs.wait-for-ci.result == 'success')
    needs: [detect-changes, wait-for-ci]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/data-ingestion-service
          cd data-ingestion-service
          docker build --platform linux/amd64 \
            -t $IMAGE:${{ github.sha }} \
            -t $IMAGE:latest \
            -f Dockerfile .
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

      - name: Deploy to EKS
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/data-ingestion-service:${{ github.sha }}
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl set image deployment/data-ingestion-service \
            data-ingestion-service=$IMAGE \
            -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/data-ingestion-service -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/data-ingestion-service -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          READY=$(kubectl get deployment data-ingestion-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment data-ingestion-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          echo "Ready: $READY / $DESIRED"
          [ "$READY" = "$DESIRED" ] || exit 1

  # ---------------------------------------------------------------------------
  # Deploy IC Score Service
  # ---------------------------------------------------------------------------
  deploy-ic-score-service:
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.ic-score-service == 'true') ||
      (github.event_name == 'push' && needs.detect-changes.outputs.ic-score-service == 'true' && needs.wait-for-ci.result == 'success')
    needs: [detect-changes, wait-for-ci]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/ic-score-service
          docker build --platform linux/amd64 \
            -t $IMAGE:${{ github.sha }} \
            -t $IMAGE:latest \
            -f ic-score-service/Dockerfile \
            ic-score-service/
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

      - name: Deploy to EKS
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/ic-score-service:${{ github.sha }}
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl set image deployment/ic-score-api \
            ic-score-api=$IMAGE \
            -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/ic-score-api -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/ic-score-api -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          READY=$(kubectl get deployment ic-score-api -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment ic-score-api -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          echo "Ready: $READY / $DESIRED"
          [ "$READY" = "$DESIRED" ] || exit 1

  # ---------------------------------------------------------------------------
  # Deploy Task Service
  # ---------------------------------------------------------------------------
  deploy-task-service:
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.task-service == 'true') ||
      (github.event_name == 'push' && needs.detect-changes.outputs.task-service == 'true' && needs.wait-for-ci.result == 'success')
    needs: [detect-changes, wait-for-ci]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/task-service
          cd task-service
          docker build --platform linux/amd64 \
            -t $IMAGE:${{ github.sha }} \
            -t $IMAGE:latest \
            -f Dockerfile .
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

      - name: Deploy to EKS
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/investorcenter/task-service:${{ github.sha }}
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl set image deployment/task-service \
            task-service=$IMAGE \
            -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/task-service -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/task-service -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Verify deployment
        run: |
          READY=$(kubectl get deployment task-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment task-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          echo "Ready: $READY / $DESIRED"
          [ "$READY" = "$DESIRED" ] || exit 1

  # ---------------------------------------------------------------------------
  # Summary
  # ---------------------------------------------------------------------------
  deploy-summary:
    if: always()
    needs:
      - deploy-frontend
      - deploy-backend
      - deploy-notification-service
      - deploy-data-ingestion-service
      - deploy-ic-score-service
      - deploy-task-service
    runs-on: ubuntu-latest
    steps:
      - name: Deployment summary
        run: |
          echo "## Deployment Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Service | Status |" >> "$GITHUB_STEP_SUMMARY"
          echo "|---------|--------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Frontend | ${{ needs.deploy-frontend.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Backend | ${{ needs.deploy-backend.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Notification Service | ${{ needs.deploy-notification-service.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Data Ingestion Service | ${{ needs.deploy-data-ingestion-service.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| IC Score Service | ${{ needs.deploy-ic-score-service.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Task Service | ${{ needs.deploy-task-service.result }} |" >> "$GITHUB_STEP_SUMMARY"

      - name: Check for failures
        if: contains(needs.*.result, 'failure')
        run: |
          echo "One or more deployments failed!"
          exit 1
